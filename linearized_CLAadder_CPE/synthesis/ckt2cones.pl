#!/usr/bin/perl

use strict;
use warnings;

my $original_nl;

my @outputs;
my @inputs;
# my @connection;
my %connection_hash;
my %node_cate;

my $output_cnt;
my $input_cnt;

# gate type list, if more gates added, just modify here
# then the gate keywords will be able to be detected by the script
my $gate_pattern = "and|inv|xor";

my $VERILOG_FILE = shift @ARGV;
$VERILOG_FILE =~ /\b(.*)\.v/;
my $VERILOG_FILE_BASE = $1;
# print "$VERILOG_FILE_BASE\n";

# subroutine writing the extracted netlist to 
# corresponding cone verilog file
# prototype process($output_node_name, \@cone)
sub process ($\@);

# Open the original circuit to be split
open CKT, $VERILOG_FILE or die $!;
open CKT_TEMP, "> temp.v" or die $!;
print "\n################# ckt2cones.pl\n\nThe verilog file: $VERILOG_FILE has been accepted\nProcess Begin...\n\n";
print "The netlist is:\n-------------------------------------\n";

while($original_nl = <CKT>)
{
	$original_nl =~ s/\/\/.*//;
	if($original_nl !~ /^\s*$/)
	{
		if($original_nl !~ /;$/)
		{
			$original_nl =~ s/\s+$//;
			chomp($original_nl);
			print CKT_TEMP $original_nl;
		}
		else
		{
			print CKT_TEMP "$original_nl";
		}
	}
}

close CKT;
close CKT_TEMP;

open CKT_TEMP, "temp.v" or die $!;

while($original_nl = <CKT_TEMP>)
{
	print $original_nl;
	chomp($original_nl);

	# Get the ouputs and store into a @outputs array
	if($original_nl =~ /output/)
	{
		# remove the keyword "output"
		# only output signal list remains looks like a, b, c, e, f;
		$original_nl =~ s/\s*output\s+//;

		# also remove the ";" at the end of output signal list
		$original_nl =~ s/;//;

		# now the signals are seperated by commas
		# split the output signal list and store in array "@outputs"
		@outputs = split /\s*,\s*/, $original_nl;

		# number of contents in @outputs
		$output_cnt = @outputs;

		#print "@outputs\n$output_cnt\n";
	}

	# Get the inputs
	elsif($original_nl =~ /input/)
	{
		$original_nl =~ s/\s*input\s+//;
		$original_nl =~ s/;//;

		@inputs = split /\s*,\s*/, $original_nl;
		$input_cnt = @inputs;

		# save each input signal as a key of hash
		# for check if a node is input signal (using "exists" function)
		# if a node is in this hash list, it indicates that this node is
		# an input signal
		for (@inputs)
		{
			$node_cate{$_} = 1;
		}

		print "@inputs\n";
	}

	# check if this is a gate description line
	# such as and2 g06(.a(n10), .b(n6), .O(e));
	elsif($original_nl =~ /assign/)
	{
		# extract the output node name of this gate into $1
		# in the above case, store "e" into $1
		$original_nl =~ /assign\s+(\w+)\s*=\s*/;

		# create hash table for this node
		# the key is the output node name in $1
		# the value is the full gate description
		# ie. {"n62", "assign n62 = c0 & j0;"}
		$connection_hash{$1} = $original_nl;

		print "$1 -> $connection_hash{$1}\n";
	}
}

# we have got all information of the whole circuit
# close it
close CKT_TEMP;
unlink "temp.v";

print "-----------------------------------------------\nFinished reading netlist file\n";

# process from each ouput node
my $output;
my $cone_cnt;
for $output (@outputs)
{
	my @cone;
	$cone_cnt++;
	# print "######################### c$cone_cnt: ###############################\n";

	# "component 0":  writing the file description line for this certain cone
	$cone[0] = "// c$cone_cnt.v generated by perl script\n\n";

	# "component 1": writing the module line signal list will be updated later
	$cone[1] = "module c$cone_cnt ();\n";

	# "component 2": writing the output signal list line (should always be only one)
	$cone[2] = "\toutput $output;\n";

	# start process the netlist and generate 
	# the main part of the netlist of this certain cone
	process($output, @cone);

	# add keyword "endmodule" to the last line
	push @cone, "endmodule\n";

	# open the netlist file to be written
	if(not -e $VERILOG_FILE_BASE)
	{
		mkdir "cones/$VERILOG_FILE_BASE", 0775;
	}
	open CONE, "> ./cones/$VERILOG_FILE_BASE/c$cone_cnt.v" or die $!;

	# print the content into the netlist file
	print CONE @cone;
	close CONE;
}

print "\nProcess Succeeded!!\nPlease check the results directory for the generated file(s)\n\n";
print "######################## ckt2cones.pl\n\n";

sub process ($\@)
{
	# read the arguments in, and save to copy to local variables
	# $cone_ref is a reference to the array @cone passed
	my ($output_node, $cone_ref) = @_;

	# used to update the module line
	my $signal_list = "$output_node, ";
	
	# used to update the input signal list
	my $input_list = "\tinput ";

	# used to update the interconnection signal list
	my $wire_list = "\twire ";

	# Occupy these two lines for input list and wire list
	# they will be updated after traversal
	$cone_ref->[3] = $wire_list;
	$cone_ref->[4] = $input_list;

	# pre-order traversal using iteration algorithm
	my @stack;
	push @stack, $output_node;

	my $node;
	my $g_cnt = 0;
	my %out_node_list;
	while(@stack)
	{
		$node = pop @stack;
		$out_node_list{$node} = 1;
		print "$node\n";

		# print "$node -> $connection_hash{$node}\n";

		# get the gate description according to the key $node
		my $gate_des = $connection_hash{$node};

		# substitute the original gate instantiation 
		# name with new name as g#
		#$gate_des =~ s/g\d+/g$g_cnt/;
		#$g_cnt++;

		# print this gate description line
		push @$cone_ref, "$gate_des\n";

		# extract the gate type and number of inputs
		#my @gate_name = $gate_des =~ /($gate_pattern)(\d*)/;
		#my $gate_type = shift @gate_name;
		#my $no_input = shift @gate_name;

		#print "$gate_type -> $no_input\n";

		my $left = "";
		my $right = "";

		if($gate_des =~ /[&\|\^]/)
		{
			($left, $right) = $gate_des =~ /~?(\w+)\s*[&\|\^]\s*~?(\w+)/;
			# print "$left, $right\n";
		}
		else
		{
			($left) = $gate_des =~ /=\s*~?(\w+)\s*;/;
		}

		if(not $right eq "")
		{
			if(not exists $out_node_list{$right})
			{
				# if right is not input node
				if(not exists $node_cate{$right})
				{
					if($wire_list !~ /\b$right\b/)
					{
						if($wire_list =~ /wire $/)
						{
							$wire_list .= $right;
						}
						else
						{
							$wire_list .= ", $right";
						}
					}

					# push right hand side child into stack
					push @stack, $right;
					$out_node_list{$right} = 1;
					# print "pushed $right\n";
				}
				# right child is input node
				# don't push into stack
				else
				{
					if($input_list !~ /\b$right\b/)
					{
						if($input_list =~ /input $/)
						{
							$input_list .= $right;
						}
						else
						{
							$input_list .= ", $right";
						}
					}
				}
			}
		}

		if(not exists $out_node_list{$left})
		{
			# if left is not input node
			if(not exists $node_cate{$left})
			{
				if($wire_list !~ /\b$left\b/)
				{
					if($wire_list =~ /wire $/)
					{
						$wire_list .= $left;
					}
					else
					{
						$wire_list .= ", $left";
					}
				}

				# push left hand side child into stack
				push @stack, $left;
				$out_node_list{$left} = 1;
				# print "pushed $left\n";
			}
			# left child is input node
			# don't push into stack
			else
			{
				if($input_list !~ /\b$left\b/)
				{
					if($input_list =~ /input $/)
					{
						$input_list .= $left;
					}
					else
					{
						$input_list .= ", $left";
					}
				}
			}
		}
	}

	# update the interconnection signal list line
	$cone_ref->[3] = $wire_list . ";\n";

	# if there are no signal in wire list, remove the wire list line
	$cone_ref -> [3] =~ s/wire\s*;//;

	# update the input signal list line
	$cone_ref->[4] = $input_list . ";\n";

	# update the module signal list line
	# first remove the keyword part
	$input_list =~ s/\tinput //;
	$signal_list .= $input_list;

	# substitute the pair of brackets with the "($signal_list)"
	$cone_ref->[1] =~ s/\(\)/($signal_list)/;
}
